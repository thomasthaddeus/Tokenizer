// eventBinders.js
import { handleCleanText, handleTruncateText } from './.handlers/handlers.js';

export function bindCleanButton(buttonSelector, inputSelector) {
  const button = document.querySelector(buttonSelector);
  button.addEventListener('click', () => {
    const options = {
      lowercase: document.getElementById('lowercase').checked,
      removeSpecialChars: document.getElementById('removeSpecialChars').checked,
      removeNumbers: document.getElementById('removeNumbers').checked,
      removePunctuation: document.getElementById('removePunctuation').checked,
      removeEmojis: document.getElementById('removeEmojis').checked,
    };
    const result = handleCleanText(inputSelector, options);
    document.querySelector(inputSelector).value = result;
  });
}

export function bindTruncateButton(buttonSelector, inputSelector, outputSelector, maxTokensSelector) {
  const button = document.querySelector(buttonSelector);
  button.addEventListener('click', () => {
    const maxTokens = parseInt(document.querySelector(maxTokensSelector).value) || 7000;
    const result = handleTruncateText(inputSelector, maxTokens);
    document.querySelector(outputSelector).value = result.truncated;
    document.querySelector('#cutOffText').value = result.cutOff; // Assuming #cutOffText is the id for cut-off text area
  });
}

// js/main.js
import { bindCleanButton, bindTruncateButton } from './eventBinders.js';

document.addEventListener('DOMContentLoaded', () => {
  bindCleanButton('#cleanButton', '#inputText');
  bindTruncateButton('#truncateButton', '#inputText', '#outputText', '#maxTokens');
});

// handlers.js
import { cleanText, truncateTokens } from '../utils/textUtils.js';

export function handleCleanText(inputSelector, options) {
  const inputText = document.querySelector(inputSelector).value;
  return cleanText(inputText, options);
}

export function handleTruncateText(inputSelector, maxTokens) {
  const inputText = document.querySelector(inputSelector).value;
  return truncateTokens(inputText, maxTokens);
}

export function generateTestText() {
  const lowerCaseText = "this is a lowercase string. ";
  const upperCaseText = "THIS IS AN UPPERCASE STRING. ";
  const numberString = "123 456 7890 ";
  const specialCharString = "!@#$%^&*()_+[];'./,<>?\":{}|=- ";
  const punctuationString = ",.;:?!-(){}[]'\" ";
  const emojiString = "😀👍🚀🌟💥🌈 ";
  const mixedText = "Mixed: ABC abc 123 🚀! ";
  const allChars =
    lowerCaseText +
    upperCaseText +
    numberString +
    specialCharString +
    punctuationString +
    emojiString;

  let randomText = "";
  for (let i = 0; i < 1000; i++) {
    const randomIndex = Math.floor(Math.random() * allChars.length);
    randomText += allChars[randomIndex];
  }

  return (
    lowerCaseText.repeat(5) +
    upperCaseText.repeat(5) +
    numberString.repeat(5) +
    specialCharString.repeat(5) +
    punctuationString.repeat(5) +
    emojiString.repeat(5) +
    mixedText.repeat(5) +
    randomText
  );
}

// Use this function to get the test text and use it for testing
const testText = generateTestText();
console.log(testText);

// textUtils.js

export function cleanText(text, options) {
  if (options.lowercase) {
      text = text.toLowerCase();
  }
  if (options.removeSpecialChars) {
      text = text.replace(/[^a-z0-9\s]/gi, '');
  }
  if (options.removeNumbers) {
      text = text.replace(/[0-9]/g, '');
  }
  if (options.removePunctuation) {
      text = text.replace(/[.,\/#!?$%\^&\*;:{}=\-_`~()]/g,"");
  }
  if (options.removeEmojis) {
      text = text.replace(/([\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F900}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}])/gu, '');
  }
  return text;
}

export function truncateTokens(text, maxTokens = 7000) {
  const tokens = text.split(/\s+/);
  return {
    truncated: tokens.slice(0, maxTokens).join(" "),
    cutOff: tokens.slice(maxTokens).join(" "),
  };
}

// tests/textFunctions.test.js
import { cleanText, truncateTokens } from '../js/utils/textUtils';

describe('Text processing tests', () => {
  it('should clean text correctly', () => {
    const testText = "Example text with numbers 123 and symbols @#$!";
    const cleanedText = cleanText(testText);
    expect(cleanedText).toBe("example text with numbers and symbols ");
  });

  it('should truncate text correctly', () => {
    const testText = "This is a long text that needs to be truncated";
    const maxTokens = 5;
    const { truncated } = truncateTokens(testText, maxTokens);
    expect(truncated.split(' ').length).toBe(maxTokens);
  });
});

// tests/textUtils.test.js
import { cleanText, truncateTokens } from '../js/utils/textUtils';
import { generateTestText } from '../js/utils/testUtils';

describe('textUtils', () => {
  describe('cleanText', () => {
    it('should convert to lowercase', () => {
      const text = 'Test String';
      expect(cleanText(text, { lowercase: true })).toBe('test string');
    });

    it('should remove special characters', () => {
      const text = 'hello@world!';
      expect(cleanText(text, { removeSpecialChars: true })).toBe('helloworld');
    });

    it('should remove numbers', () => {
      const text = 'Text with numbers 12345';
      expect(cleanText(text, { removeNumbers: true })).toBe('Text with numbers ');
    });

    it('should remove punctuation', () => {
      const text = 'Hello, world! How are you?';
      expect(cleanText(text, { removePunctuation: true })).toBe('Hello world How are you');
    });

    it('should remove emojis', () => {
      const text = 'Hello 😊👍🏻';
      expect(cleanText(text, { removeEmojis: true })).toBe('Hello ');
    });

    it('should handle multiple cleaning options', () => {
      const text = 'TEST String 1234!@#$ 😊';
      const options = {
        lowercase: true,
        removeSpecialChars: true,
        removeNumbers: true,
        removePunctuation: true,
        removeEmojis: true
      };
      expect(cleanText(text, options)).toBe('test string  ');
    });

    it('should return the original text if no options are provided', () => {
      const text = 'Original Text 1234!@#$ 😊';
      expect(cleanText(text, {})).toBe('Original Text 1234!@#$ 😊');
    });

    it('should clean text correctly', () => {
      const text = 'Some text with various Elements 1234!@#$ 😊';
      const options = { lowercase: true, removeSpecialChars: true, removeNumbers: true, removePunctuation: true, removeEmojis: true };
      const cleanedText = cleanText(text, options);
      expect(cleanedText).not.toMatch(/[0-9!@#$%^&*()_+]/);
    });

  });

  describe('truncateTokens', () => {
    it('should truncate text to the specified number of tokens', () => {
      const text = generateTestText();
      const { truncated, cutOff } = truncateTokens(text, 10);
      expect(truncated.split(/\s+/).length).toBeLessThanOrEqual(10);
      // Additional assertions can be made about the `cutOff` part or the complete functionality
    });

    it('should not truncate if text is within the limit', () => {
      const text = 'This is a short text.';
      const { truncated, cutOff } = truncateTokens(text, 10);
      expect(truncated).toBe('This is a short text.');
      expect(cutOff).toBe('');
    });

    it('should handle empty string', () => {
      const text = '';
      const { truncated, cutOff } = truncateTokens(text, 10);
      expect(truncated).toBe('');
      expect(cutOff).toBe('');
    });

    it('should truncate text correctly when text is longer than the limit', () => {
      const text = generateTestText(); // This should generate a long string
      const maxTokens = 50;
      const { truncated, cutOff } = truncateTokens(text, maxTokens);
      expect(truncated.split(/\s+/).length).toBeLessThanOrEqual(maxTokens);
      expect(truncated.length + cutOff.length).toBe(text.length);
    });

    it('should handle cases where maxTokens is zero', () => {
      const text = 'This should be entirely cut off.';
      const { truncated, cutOff } = truncateTokens(text, 0);
      expect(truncated).toBe('');
      expect(cutOff).toBe(text);
    });

  });
});

